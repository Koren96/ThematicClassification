# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SupervisedClassification
                                 A QGIS plugin
 This plugin can classify satellite images using different methods of supervised classification.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Mattia Koren
        email                : korenmattia@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox, QDialog, QProgressBar
from qgis.PyQt.QtWidgets import QVBoxLayout, QWidget, QSizePolicy
from qgis.core import QgsProject, Qgis
from qgis.gui import QgsMessageBar
from PyQt5 import QtGui
import time
import numpy as np
from osgeo import gdal
from sklearn.cluster import MiniBatchKMeans
from sklearn.naive_bayes import GaussianNB
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import LinearSVC
from sklearn.neural_network import MLPClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import RidgeClassifier
from joblib import dump, load
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .supervised_classification_dialog import SupervisedClassificationDialog
from .probar_dialog import Ui_Form
import os.path
import webbrowser
from datetime import datetime

class SupervisedClassification:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'SupervisedClassification_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Supervised Classification')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('SupervisedClassification', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/supervised_classification/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Supervised Classification'),
            callback=self.run,
            parent=self.iface.mainWindow())
        # will be set False in run() 
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Supervised Classification'),
                action)
            self.iface.removeToolBarIcon(action)
       
    def selectClassifiedFile(self):
        filename, _filter = QFileDialog.getSaveFileName(self.dlg, "Select output file ","", '*.tiff')
        self.dlg.leClassName.setText(filename)

    def selectModelFile(self):
        modelname, _filter = QFileDialog.getSaveFileName(self.dlg, "Select output file ","", '*.joblib')
        self.dlg.leModelName.setText(modelname)

    def selectExistentModel(self):
        modelname, _filter = QFileDialog.getOpenFileName(self.dlg, "Open Image","", "*.joblib")
        self.dlg.leModelNameEx.setText(modelname)

    def changeparameters(self):
        if self.dlg.cSVM.isChecked():
            self.dlg.leParameters.setText("l2;squared_hinge;False;0.0001;1.0;ovr;True;1;None;0;None;1000")
        elif self.dlg.cGaussianNB.isChecked():
            self.dlg.leParameters.setText("None;1e-9")
        elif self.dlg.cNearestN.isChecked():
            self.dlg.leParameters.setText("5;uniform;auto;30;2;minkowski;None;None")
        elif self.dlg.cNeuralNetwork.isChecked():
            self.dlg.leParameters.setText("100;relu;adam;0.0001;auto;constant;0.001;0.5;200;True;None;0.0001;False;False;0.9;True;False;0.1;0.9;0.999;1e-08;10;15000")
        elif self.dlg.cLogReg.isChecked():
            self.dlg.leParameters.setText("l2;False;0.0001;1.0;True;1;None;None;lbfgs;100;auto;0;False;None;None")
        elif self.dlg.cRandForest.isChecked():
            self.dlg.leParameters.setText("100;gini;None;2;1;0.0;sqrt;None;0.0;True;False;None;None;0;False;None;0.0;None")
        elif self.dlg.cKmeans.isChecked():
            self.dlg.leParameters.setText("8;k-means++;100;1024;0;True;None;0.0;10;None;auto;0.01")

    def opendocumentationpage(self):
        if self.dlg.cGaussianNB.isChecked():
            url = "https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html#sklearn.naive_bayes.GaussianNB"
        elif self.dlg.cSVM.isChecked():
            url ="https://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC"
        elif self.dlg.cLogReg.isChecked():
            url ="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression"
        elif self.dlg.cNearestN.isChecked():
            url ="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier"
        elif self.dlg.cRandForest.isChecked():
            url ="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier"
        elif self.dlg.cNeuralNetwork.isChecked():
            url ="https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPClassifier.html#sklearn.neural_network.MLPClassifier"
        elif self.dlg.cKmeans.isChecked():
            url = "https://scikit-learn.org/stable/modules/generated/sklearn.cluster.MiniBatchKMeans.html#sklearn.cluster.MiniBatchKMeans"
        webbrowser.open(url, new=0, autoraise=True)

    def cleantraindata(self,arrX,arrY,trainnband,nval):
        arrX = np.transpose(arrX.reshape(trainnband,-1))
        arrY = arrY.reshape(-1,1)
        t = np.hstack((arrX,arrY))
        t = t[t[:,-1] != nval]
        t = t.astype(int)
        arrX,arrY = np.hsplit(t,[trainnband])
        return arrX,arrY

    def splitclass(self,test_input,nc,model,totimp,gx,gy,p,nodatax,nodatay,par):   
        # classification
        if self.dlg.cSVM.isChecked():
            rule_output = np.empty((0,len(model.classes_)), dtype = np.float32)
        if self.dlg.cKmeans.isChecked():
            rule_output = np.empty((0,int(par)), dtype = np.float32)
        else:
            rule_output = np.empty((0,len(model.classes_)), dtype = np.uint16)
        nodataindex = np.where(np.all(test_input == nodatax, axis=1))
        x = np.asarray(np.delete(np.linspace(0,test_input.shape[0],nc+1),[0,nc]),int)
        test_output = np.empty(0,dtype=int)
        totClassifiedChunks=0
        #list of chuncks
        y = np.split(test_input,x)
        for i in range(nc):
            chunkoutput = model.predict(y[i])                
            totClassifiedChunks+=1
            print('Classified chunks: ', totimp*nc+totClassifiedChunks,'/',gx*gy*nc,sep='', end='\r')
            test_output = np.hstack((test_output,chunkoutput))
            #rule image
            if self.dlg.cbRuleImage.isChecked():
                if self.dlg.cSVM.isChecked():
                    rulechunk = model.decision_function(y[i]).astype(np.float32)
                elif self.dlg.cKmeans.isChecked():
                    rulechunk = model.transform(y[i]).astype(np.uint16)
                else:
                    rulechunk = model.predict_proba(y[i])
                    rulechunk = (rulechunk*10000).astype(np.uint16)          
                rule_output = np.vstack((rule_output,rulechunk))
            # Update progress
            p = p + (38/(gx*gy*nc))
            self.dlg.progressBar.setValue(int(p))
        test_output = np.ravel(test_output)
        test_output[nodataindex] = nodatay
        return test_output, rule_output, p

    def supervisedclass(self, my_msg_bar): 
        self.dlg.ptLog.clear()  
        prog = 0
        self.dlg.progressBar.setValue(prog)

        # Current time
        string = "Started at: " + datetime.now().strftime("%H:%M:%S")
        self.dlg.ptLog.appendPlainText(string)
        startTime = time.time() 

        # Import variables from GUI       
        nullval = self.dlg.sbNullValue.value() #null value of training image
        filename = self.dlg.leClassName.text() #output name
      
        if len(self.dlg.TestInputList.checkedItems()) == 0:
            my_msg_bar.pushMessage("Error", "Missing input image bands.", Qgis.Critical)
            return                      
        if len(filename) == 0:
            my_msg_bar.pushMessage("Error", "Missing output classification image name.", Qgis.Critical)
            return 
        
        # nColumns e nRows variables
        if self.dlg.cImageGrid.isChecked():
            gridX = self.dlg.sbGridX.value()
            gridY = self.dlg.sbGridY.value()
        else:
            gridX = 1
            gridY = 1
        if gridX <= 0 or gridY <=0:
            my_msg_bar.pushMessage("Error", "The number of rows and columns must be larger than or equal to 1.", Qgis.Critical)
            return

        # Chunks variables
        if self.dlg.cClassChunks.isChecked():
            nchunks = self.dlg.sbChunks.value()
        else:
            nchunks = 1
        if nchunks <=0:
            my_msg_bar.pushMessage("Error", "The number of tiles must be larger than or equal to 1.", Qgis.Critical)
            return 

        self.dlg.progressBar.setValue(3)

        # Open image bands
        openLayers = []
        firstband = True
        
        for testband in self.dlg.TestInputList.checkedItems():
            layer = QgsProject.instance().mapLayersByName(testband)
            layer = layer[0].dataProvider().dataSourceUri()
            openLayers.append(gdal.Open(layer,0))
            if firstband == True:
                driver = gdal.GetDriverByName('GTiff')
                dataset = driver.CreateCopy(filename,openLayers[0])
                xSize = openLayers[0].RasterXSize
                ySize = openLayers[0].RasterYSize
                firstband = False
            prog = prog + (10/(len(self.dlg.TestInputList.checkedItems())))
            self.dlg.progressBar.setValue(int(prog))
        string = 'Input image band: ' + str(self.dlg.TestInputList.checkedItems())
        self.dlg.ptLog.appendPlainText(string)

        # No data values 
        nodataval = np.repeat(self.dlg.sbNoDataValue.value(),len(openLayers))
        nodataclass = self.dlg.sbNoDataClass.value()

        xStep = int(xSize/gridX) #chunk width
        yStep = int(ySize/gridY) #chunk height
        xRes = xSize - xStep*gridX #x residual
        yRes = ySize - yStep*gridY #y residual
        totImportedChunks = 0

        # Use an existing model
        if self.dlg.cbUseModel.isChecked():
            modelname = self.dlg.leModelNameEx.text()
            if len(modelname)==0:
                my_msg_bar.pushMessage("Error", "Missing classification model name", Qgis.Critical)
                return
            # Load model and check
            mod = load(modelname)   
            if len(self.dlg.TestInputList.checkedItems()) != mod.n_features_in_:
                message = "The loaded model expects {} features, but the image to be classified has{}".format(mod.n_features_in_, len(self.dlg.TestInputList.checkedItems()))########################################
                my_msg_bar.pushMessage("Error", "message", Qgis.Critical)
                return
            else:
                string = "Model successfully loaded: "+ modelname
                self.dlg.ptLog.appendPlainText(string)

        # Create Model from training dataset
        else:

            startTimeTrain = time.time()       
            algorithm = None
            # Parameters list
            parameters=self.dlg.leParameters.text().split(';')
            # Create empty arrays for training 
            trainx = np.empty((0,len(openLayers)), dtype = int)
            trainy = np.empty((0,1), dtype = int)

            #training for K-means
            if self.dlg.cKmeans.isChecked():
                algname = 'K-Means'
                #parameters
                if parameters[6] == 'None':
                    parameters[6] = None
                else:
                    parameters[6] = int(parameters[6])
                if parameters[9] == 'None':
                    parameters[9] = None
                else:
                    parameters[9] = int(parameters[9])
                if parameters[10] != 'auto' and parameters[10] != 'warn' :
                    parameters[10] = int(parameters[10])

                algorithm = MiniBatchKMeans(n_clusters=int(parameters[0]), init=parameters[1], max_iter=int(parameters[2]), batch_size=int(parameters[3]), verbose=int(parameters[4]), compute_labels=eval(parameters[5]), random_state=parameters[6], tol=float(parameters[7]), max_no_improvement=int(parameters[8]), init_size=parameters[9], n_init=parameters[10], reassignment_ratio=float(parameters[11]))
                # fitting the model in chunks          
                for j in range(gridY):
                    for i in range(gridX):
                        testBandsChunk = []
                        if i==(gridX-1) and j==(gridY-1):
                            winX = xRes+xStep
                            winY = yRes+yStep            
                        elif j==(gridY-1):
                            winX = xStep
                            winY = yRes+yStep
                        elif i==(gridX-1):
                            winX = xRes+xStep
                            winY = yStep 
                        else:
                            winX = xStep
                            winY = yStep
                        for k in range(len(openLayers)):
                            testBandsChunk.append(openLayers[k].ReadAsArray(xStep*i,yStep*j,winX,winY))
                        testChunkX = np.stack(testBandsChunk)
                        testChunkX = np.transpose(testChunkX.reshape(testChunkX.shape[0],-1))
                        mod = algorithm.partial_fit(testChunkX)
                        prog = prog + (40/(gridX*gridY))
                        self.dlg.progressBar.setValue(int(prog))

                trainTime= time.time()-startTimeTrain
                string = "Training completed in: " + str(int(trainTime/60)) + ":" + str(int(trainTime%60)) + " minutes"      
                self.dlg.ptLog.appendPlainText(string)
                string = 'Algorithm: '+ algname + ', parameters: '+ str(self.dlg.leParameters.text())
                self.dlg.ptLog.appendPlainText(string)
                my_msg_bar.pushMessage("Status", "Training completed.", Qgis.Info)
                prog = 50
                self.dlg.progressBar.setValue(prog)

            else:

                # Check if training output is selected by user
                if self.dlg.TrainOutput.currentLayer() is None:
                    my_msg_bar.pushMessage("Error", "Missing output classification image.", Qgis.Critical)
                    return
                # Open training output
                layer = self.dlg.TrainOutput.currentLayer().dataProvider().dataSourceUri()
                opentrainy = gdal.Open(layer)
                string = 'Input training data: ' + str(self.dlg.TrainOutput.currentLayer())
                self.dlg.ptLog.appendPlainText(string)
          
                # Populate training arrays removing null values           
                for j in range(gridY):
                    for i in range(gridX):
                        testBandsChunk = []
                        if i==(gridX-1) and j==(gridY-1):
                            winX = xRes+xStep
                            winY = yRes+yStep            
                        elif j==(gridY-1):
                            winX = xStep
                            winY = yRes+yStep
                        elif i==(gridX-1):
                            winX = xRes+xStep
                            winY = yStep 
                        else:
                            winX = xStep
                            winY = yStep
                        for k in range(len(openLayers)):
                            testBandsChunk.append(openLayers[k].ReadAsArray(xStep*i,yStep*j,winX,winY))
                        testChunkX = np.stack(testBandsChunk)
                        testChunkY = opentrainy.ReadAsArray(xStep*i,yStep*j,winX,winY)
                        testChunkX, testChunkY = self.cleantraindata(testChunkX,testChunkY,testChunkX.shape[0],nullval)
                        trainx = np.vstack((trainx,testChunkX))
                        trainy = np.vstack((trainy,testChunkY))       
                        prog = prog + (20/(gridX*gridY))
                        self.dlg.progressBar.setValue(int(prog))     
                                    
                # Create an algorithm with the parameters 
                #Gaussian Naive-Bayes
                if self.dlg.cGaussianNB.isChecked(): 
                    algname = 'Gaussian Naive-Bayes'                  
                    if parameters[0] == 'None':
                        parameters[0] = None
                    algorithm = GaussianNB(priors=parameters[0], var_smoothing = float(parameters[1]))
                #K-Nearest Neighbour
                if self.dlg.cNearestN.isChecked():
                    algname = 'K-Nearest Neighbour'
                    if parameters[1] == 'None':
                        parameters[1] = None
                    if parameters[6] == 'None':
                        parameters[6] = None
                    if parameters[7] == 'None':
                        parameters[7] = None
                    else:
                        parameters[7] = int(parameters[7])
                    algorithm = KNeighborsClassifier(n_neighbors=parameters[0], weights=parameters[1], algorithm=parameters[2], leaf_size=int(parameters[3]), p=int(parameters[4]), metric=parameters[5], metric_params=parameters[6], n_jobs=parameters[7])
                #Linear SVC
                if self.dlg.cSVM.isChecked():
                    algname = 'Linear SVC'
                    if parameters[8] == 'None':
                        parameters[8] = None
                    if parameters[10] == 'None':
                        parameters[10] = None
                    algorithm = LinearSVC(penalty=parameters[0], loss=parameters[1], dual=eval(parameters[2]), tol=float(parameters[3]), C=float(parameters[4]), multi_class=parameters[5], fit_intercept=eval(parameters[6]), intercept_scaling=float(parameters[7]), class_weight=parameters[8], verbose=int(parameters[9]), random_state=parameters[10], max_iter=int(parameters[11]))
                #Neural Networks
                if self.dlg.cNeuralNetwork.isChecked():
                    algname = 'Neural Networks'
                    if parameters[4] != 'auto':
                        parameters[4] = int(parameters[4])
                    if parameters[10] == 'None':
                        parameters[10] = None
                    else:
                        parameters[10] = int(parameters[10])
                    algorithm = MLPClassifier(hidden_layer_sizes=(int(parameters[0]),), activation=parameters[1], solver=parameters[2], alpha=float(parameters[3]), batch_size=parameters[4], learning_rate=parameters[5], learning_rate_init=float(parameters[6]), power_t=float(parameters[7]), max_iter=int(parameters[8]), shuffle=eval(parameters[9]), random_state=parameters[10], tol=float(parameters[11]), verbose=eval(parameters[12]), warm_start=eval(parameters[13]), momentum=floatl(parameters[14]), nesterovs_momentum=eval(parameters[15]), early_stopping=eval(parameters[16]), validation_fraction=float(parameters[17]), beta_1=float(parameters[18]), beta_2=float(parameters[19]), epsilon=float(parameters[20]), n_iter_no_change=int(parameters[21]), max_fun=int(parameters[22]))
                #Logistic Regression
                if self.dlg.cLogReg.isChecked():
                    algname = 'Logistic Regression'
                    if parameters[6] == "None":
                        parameters[6] = None
                    if parameters[7] == "None":
                        parameters[7] = None
                    if parameters[13] == "None":
                        parameters[13] = None
                    else:
                        parameters[13] = int(parameters[13])
                    if parameters[14] == "None":
                        parameters[14] = None
                    else:
                        parameters[14] = float(parameters[14])
                    algorithm = LogisticRegression(penalty=parameters[0], dual=eval(parameters[1]), tol=float(parameters[2]), C=float(parameters[3]), fit_intercept=eval(parameters[4]), intercept_scaling=float(parameters[5]), class_weight=parameters[6], random_state=parameters[7], solver=parameters[8], max_iter=int(parameters[9]), multi_class=parameters[10], verbose=int(parameters[11]), warm_start=eval(parameters[12]), n_jobs=parameters[13], l1_ratio=parameters[14])
                #Random Forest
                if self.dlg.cRandForest.isChecked():
                    algname = 'Random Forest'
                    if parameters[2] == "None":
                        parameters[2] = None
                    else:
                        parameters[2] = int(parameters[2])
                    if parameters[7] == "None":
                        parameters[7] = None
                    else:
                        parameters[7] = int(parameters[7])
                    if parameters[11] == "None":
                        parameters[11] = None
                    else:
                        parameters[11] = int(parameters[11])
                    if parameters[12] == "None":
                        parameters[12] = None
                    else:
                        parameters[12] = int(parameters[12])
                    if parameters[15] == "None":
                        parameters[15] = None
                    algorithm = RandomForestClassifier(n_estimators=int(parameters[0]), criterion=parameters[1], max_depth=parameters[2], min_samples_split=float(parameters[3]), min_samples_leaf=float(parameters[4]), min_weight_fraction_leaf=float(parameters[5]), max_features=parameters[6], max_leaf_nodes=parameters[7], min_impurity_decrease=float(parameters[8]), bootstrap=eval(parameters[9]), oob_score=eval(parameters[10]), n_jobs=parameters[11], random_state=parameters[12], verbose=int(parameters[13]), warm_start=eval(parameters[14]), class_weight=parameters[15], ccp_alpha=float(parameters[16]), max_samples=float(parameters[17]))
            
                prog = 35
                self.dlg.progressBar.setValue(prog)  

                # Fit the model
                trainy = np.ravel(trainy)
                mod = algorithm.fit(trainx,trainy)
                # Training time
                trainTime= time.time()-startTimeTrain
                string = "Training completed in: " + str(int(trainTime/60)) + ":" + str(int(trainTime%60)) + " minutes"      
                self.dlg.ptLog.appendPlainText(string)
                string = 'Algorithm: '+ algname + ', parameters: '+ str(self.dlg.leParameters.text())
                self.dlg.ptLog.appendPlainText(string)
                my_msg_bar.pushMessage("Status", "Training completed.", Qgis.Info)

                prog = 50
                self.dlg.progressBar.setValue(prog) 

                # Check accuracy of the model and classify
                if self.dlg.cAccuracy.isChecked():               
                    X_train, X_test, y_train, y_test = train_test_split(trainx,trainy, test_size=0.3, random_state=0)
                    y_pred = algorithm.fit(X_train,y_train).predict(X_test)
                    string = "Number of mislabeled points out of a total " + str(X_test.shape[0]) + " points: " + str((np.transpose(y_test) != y_pred).sum())
                    self.dlg.ptLog.appendPlainText(string)
                    string = "Model accuracy: " + ("{:.2f}".format((((X_test.shape[0]-((np.transpose(y_test) != y_pred).sum()))/X_test.shape[0])*100))) +" %"
                    self.dlg.ptLog.appendPlainText(string)
                    prog = 57
                    self.dlg.progressBar.setValue(prog) 
                    del(X_train, X_test, y_train, y_test,y_pred)

            # Save model in .joblib format
            if self.dlg.cKmeans.isChecked() != True:
                if self.dlg.cSaveModel.isChecked():
                    modelname = self.dlg.leModelName.text()
                    if modelname is None:
                        my_msg_bar.pushMessage("Error", "Missing classification model name.", Qgis.Critical)
                        return
                    else:
                        dump(mod,modelname)
                        string = "Model saved successfully in: " + modelname
                        self.dlg.ptLog.appendPlainText(string)

            # Delete training arrays
            del(trainx,trainy)

        prog = 60
        self.dlg.progressBar.setValue(prog)

        # Create .tif file for rule image
        if self.dlg.cbRuleImage.isChecked():
            if self.dlg.cSVM.isChecked():
                ruletype=gdal.GDT_Float32
                nbands =len(mod.classes_)
            elif self.dlg.cKmeans.isChecked():
                ruletype=gdal.GDT_UInt16
                nbands = int(parameters[0])
            else:
                ruletype=gdal.GDT_UInt16
                nbands =len(mod.classes_)
            rulename=filename.split('.') 
            rulename=rulename[0]+"_rule_image.tif"
            ruledataset=driver.Create(rulename, xsize=xSize, ysize=ySize, bands=nbands, eType=ruletype)

        # Classification
        startTimeClass = time.time()           
        for j in range(gridY):
            for i in range(gridX):
                testBandsChunk = []
                if i==(gridX-1) and j==(gridY-1):
                    winX = xRes+xStep
                    winY = yRes+yStep            
                elif j==(gridY-1):
                    winX = xStep
                    winY = yRes+yStep
                elif i==(gridX-1):
                    winX = xRes+xStep
                    winY = yStep 
                else:
                    winX = xStep
                    winY = yStep
                for k in range(len(openLayers)):
                    testBandsChunk.append(openLayers[k].ReadAsArray(xStep*i,yStep*j,winX,winY))
                testChunkX = np.stack(testBandsChunk)
                testChunkX = np.transpose(testChunkX.reshape(testChunkX.shape[0],-1))
                # Classify chunk
                testChunkY, ruleChunk, prog = self.splitclass(testChunkX,nchunks,mod,totImportedChunks,gridX,gridY,prog,nodataval,nodataclass,parameters[0])
                totImportedChunks+=1
                testChunkY = testChunkY.reshape((winY,winX))
                # Write classified chunk 
                dataset.GetRasterBand(1).WriteArray(testChunkY,xStep*i,yStep*j)
                # Write rule image chunk
                if ruleChunk.shape[0] != 0:
                    ruleChunk = ruleChunk.reshape((winY,winX,ruleChunk.shape[1]))
                    for l in range(ruleChunk.shape[2]):
                        ruledataset.GetRasterBand(l+1).WriteArray(ruleChunk[:,:,l],xStep*i,yStep*j)
                    print("rule written")
                

        prog = 98
        self.dlg.progressBar.setValue(prog)
        # Calculate classification time
        classTime = time.time() - startTimeClass
        string = "Image classified in: " + str(int(classTime/60)) + ":" + str(int(classTime%60)) + " minutes, loading the image in " + str(gridX*gridY) + " pieces, and classifying every piece divided in "+ str(nchunks) + " chunks"
        self.dlg.ptLog.appendPlainText(string)
        string = "Classified Image saved in: " + filename
        self.dlg.ptLog.appendPlainText(string)
        
        # Save Log in txt file
        if self.dlg.cbSaveLog.isChecked():
            logname=filename.split('.') 
            logname =logname[0]+"_log.txt"
            logfile = open(logname, "w")
            logfile.write(self.dlg.ptLog.toPlainText())
            logfile.close()

        # Clear variables        
        del(testChunkX, testChunkY)
        openLayers = None
        dataset.FlushCache()
        dataset = None
        if self.dlg.cbRuleImage.isChecked():
            string = "Rule image saved in: " + rulename
            self.dlg.ptLog.appendPlainText(string)
            ruledataset.FlushCache()
            ruledataset = None

        # Add output layer in the current QGIS Project
        layerName = filename.split('/')
        layerName = layerName[-1].split('.')
        self.iface.addRasterLayer(filename,layerName[0])
        self.dlg.progressBar.setValue(100)

    def resetUI(self):
        self.dlg.TestInputList.clear()
        self.dlg.leClassName.clear()
        self.dlg.leModelName.clear()
        self.dlg.leModelNameEx.clear()
        self.dlg.cbUseModel.setChecked(False)
        self.dlg.cImageGrid.setChecked(False)
        self.dlg.cClassChunks.setChecked(False)
        self.dlg.cbCustomParameters.setChecked(False)
        self.dlg.cAccuracy.setChecked(False)
        self.dlg.cSaveModel.setChecked(False)
        self.dlg.cbSaveLog.setChecked(False)
        self.dlg.cbRuleImage.setChecked(False)
        self.dlg.cGaussianNB.setChecked(True)
        self.dlg.sbGridX.setValue(1)
        self.dlg.sbGridY.setValue(1)
        self.dlg.sbChunks.setValue(1)
        self.dlg.sbNullValue.setValue(-1)
        self.dlg.sbNoDataValue.setValue(0)
        self.dlg.sbNoDataClass.setValue(0)      
        # Populate the comboBox with names of all the loaded layers
        layers = QgsProject.instance().layerTreeRoot().children()
        self.dlg.TestInputList.addItems([layer.name() for layer in layers])
        self.dlg.leParameters.setText("None;1e-9")
        self.dlg.ptLog.clear()
        self.dlg.progressBar.setValue(0)

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = SupervisedClassificationDialog()
            self.dlg.pbBrowseClass.clicked.connect(self.selectClassifiedFile)
            self.dlg.pbModelName.clicked.connect(self.selectModelFile)
            self.dlg.pbBrowseModel.clicked.connect(self.selectExistentModel)
            self.dlg.cSVM.clicked.connect(self.changeparameters)
            self.dlg.cGaussianNB.clicked.connect(self.changeparameters)
            self.dlg.cLogReg.clicked.connect(self.changeparameters)
            self.dlg.cNearestN.clicked.connect(self.changeparameters)
            self.dlg.cNeuralNetwork.clicked.connect(self.changeparameters)
            self.dlg.cRandForest.clicked.connect(self.changeparameters)
            self.dlg.cKmeans.clicked.connect(self.changeparameters)
            self.dlg.pbHelp.clicked.connect(self.opendocumentationpage)
            self.dlg.buttonBox.accepted.disconnect()
            self.dlg.buttonBox.accepted.connect(self.run)
            self.dlg.pbReset.clicked.connect(self.resetUI)
            # Fetch the currently loaded layers
            layers = QgsProject.instance().layerTreeRoot().children()      
            # Clear the contents of the comboBox and Lists from previous runs
            self.dlg.TestInputList.clear()
            self.dlg.leClassName.clear()
            self.dlg.leModelName.clear()
            self.dlg.leModelNameEx.clear()
            # Populate the comboBox with names of all the loaded layers
            self.dlg.TestInputList.addItems([layer.name() for layer in layers])
            self.dlg.leParameters.setText("None;1e-9")

        #insert message bar in layout 
        current_layout = self.dlg.layout()
        
        #create a container widget
        widget = QWidget(self.dlg)
        #current_layout.addWidget(widget)
        
        #creates message bar
        my_msg_bar = QgsMessageBar(self.dlg)
        #my_msg_bar = QgsMessageBar(widget)
        
        #sets size policy for message bar
        size_policy = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        my_msg_bar.setSizePolicy(size_policy)
        
        #add message bar to container widget
        current_layout.addWidget(my_msg_bar)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            self.supervisedclass(my_msg_bar)
            